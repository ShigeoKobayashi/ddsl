<!DOCTYPE html "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">

<head>
<title>DDSL: Digital Dynamic Simulation Library for C/C++,based on Graph Theory</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="keywords" content="DDSL(Digital Dynamic Simulation Library for C/C++,based on Graph Theory)">
<meta name="description" content="Digital Dynamic Simulation Library for C/C++">
<style type=text/css>
body {color: #3f0f0f; background: #efefef; margin-left: 4em; margin-right: 4em;}
h1 {color: #f0f0f0; background-color: #30A0FF; border-color: #FF00FF; width: 100%;
    border-style: solid; border-top-width: 0.1em; border-bottom-width: 0.1em; border-right: none;
    border-left: none;   padding: 0.1em; font-weight: bold; font-size: 160%;text-align: center;
}
h2 {color: #00007f; background-color: #e7e7ff; border-color: #949494;
    width: 100%; border-style: solid;
    border-left: 0.6em solid #30A0FF;
    border-right: none; border-top-width: 0.1em;
    border-bottom-width: 0.1em;  padding: 0.1em;  font-weight: bold;  font-size: 110%;
}
h3 {color: #00007f; padding: 0.2em; font-size: 110%;
    border-style: solid;
    border-left: none; border-right: none; border-top-width: 0.05em;
    border-bottom-width: 0.05em; 
}
h4, h5 { color: #000000; padding: 0.2em; font-size: 100%;}
table {border-style: solid; border-width: 1px; border-color: #00007f;border-right: 0px; }
th {background: #e7e7ff; border-color: #00007f; border-width: 1px; border-style: solid; border-left: 0px; border-top: 0px;}
td {background: #f3f7ff; border-color: #00007f; border-width: 1px; border-style: solid; border-left: 0px; border-bottom: 0px; border-top: 0px;}
dt {margin-top: 0.2em; border-width: 0px;}
caption { color: #7f0000;font-weight: bold;}
pre { margin-top: 1px;}
code { margin-top: 1px; color: #0000ff;}
kbd { color: #ffffbf;font-weight: bold;}
blockquote { margin-top: 0px;}
</style>
</head>

<body>
<hr/>
<h1>DDSL: Digital Dynamic Simulation Library for C/C++,based on Graph Theory</h1>

<div align="right">
This software can be redistributed under <a href="https://www.gnu.org/licenses/lgpl-3.0.en.html" target="_new">GNU Lesser General Public License</a>.<br/> And <a href="https://github.com/ShigeoKobayashi/ddsl/" target="_new">every source codes can be obtained through GitHub</a><br/>
Copylight (c) 2020 Shigeo Kobayashi. All rights reserved.<br/>
<a href="./ddsl_jp.html">[==&gt;Japanese]</a>
</div>
<table width="100%"><tr><td><a href="#OVER_VIEW">Overview</a></td><td><a href="#FLAG">Flags(Attributes)</a></td><td><a href="#API_REF">API references</a></td><td><a href="#REF">References</a></td></tr></table>
<p/>
<b>DDSL(<U>D</U>igital <U>D</U>ynamic <U>S</U>imulation <U>L</U>ibrary for C/C++,based on Graph Theory)</b> is the library to assist numerical simulation for <b>dynamics and statics</b>.<br/>
<b>DDSL</b> implements <b>Newton-method</b> for <a href="#TRIANGULAR">solving non-linear algebraic eqution systems<a> for static simulation and <b>Euler,Backward Euler,and Runge-Kutta methods</b> for <a href="#INTEGRATED">solving ordinary differential equation systems</a> for dynamic simulation.<br/>
The users,although,need not use these methos directly.<br/>
With the assistance of Graph-theory(about the theory,see <a href="#REF">References</a>.),
DDSL automaticaly determines computation sequence,constructs non-linear equation and ordinary differential equation systems if necessary,and solve them.

<a name="OVER_VIEW"/>
<h2>Overview</h2>
<table wodth="100%"><tr><td><a href="#PROCESSOR">DDS_PROCESSOR</a></td><td><a href="#VARIABLE">DDS_VARIABLE</a></td></tr></table>
To utilize DDSL,the user must define at least one processor(<a href="#PROCESSOR">DDS_PROCESSOR</a>) and more than or equal to one variable(<a href="#VARIABLE">DDS_VARIABLE</a>).<br/>
The processor(DDS_PROCESSOR) keeps every variables(DDS_VARIABLE) and solves algebraic and ordinary differential equations.

<p/>
<table width="100%"><tr><td><b>As is shown in the examples bellow,setting <a href="#REQUIRED">DDS_FLAG_REQUIRED</a> flag is the most important for the user. DDSL does everything,including computation order construction,
to compute the variables of <a href="#REQUIRED">DDS_FLAG_REQUIRED</a> flag.</b>
</td></tr></table>
<p/>

DDS_PROCESSOR and DDS_VARIABLE are pointers of the structures defined in ddsl.h.<p/>
<b>Note:</b> Include ddsl.h in the source code and link appropriate libraries(including DDSL library).<br/>
<b>Note:</b> Any name offered by this library has prefix "DDS_" or "Dds".

<a name="PROCESSOR"/>
<h3>DDS_PROCESSOR</h3>
To define DDS_PROCESSOR:
<code><pre>
    DDS_PROCESSOR p;
    int e = DdsCreateProcessor(&p,10);
    if(e!=0) printf("DdsCreateProcessor() returned an error\n");
</pre></code>
<a href="#DdsCreateProcessor">DdsCreateProcessor(&p,10)</a> allocates memories for DDS_PROCESSOR structure and sets it's pointer to p. The second argument 10 is the number of variables(explained later) the DdsProcessor() can keep which will be automatically extended if necessary. DdsCreateProcessor() returns 0 if DdsProcessor is normally allocated,or returns non-zero error code.<p/>
<b>Note:</b>DdsCreateProcessor() automatically allocates default variables,<a href="#DdsTime">time</a> and integration <a href="#DdsStep">step</a>,internally.

<a name="VARIABLE"/>
<h3>DDS_VARIABLE in the simple static example</h3>
The variable(DDS_VARIABLE) has value(double),<a href="#FLAG">flags/attributes(unsigned int)</a>,and may have right hand side variables(hereinafter referred to as <b>RHSV</b>s) and the function pointer to compute it's value(<u><b>Note:</b> The user must not change the variable's value and any other's within that function. DDSL does that instead of the user.</u>).
<br/>
<b>Definition:</b><blockquote>
<b>Upstream</b>: In case like <b>y = f(u,v,w)</b>.  Variables u,v,and w are <b>upstream</b> variables of y.<br/>
<b>Downstream</b>:  In case like <b>x = f(y)</b>. Variable x is a <b>downstream</b> variable of y.
</blockquote>

Variables must be registered to the processor(DDS_PROCESSOR) as:
<table width="100%">
<tr><td>
<img src="./fx.png">
</td><td>
<code><pre>
    DDS_PROCESSOR p;
    DDS_VARIABLE y,x1,x2;
    DdsCreateProcessor(&p,10);
    DdsAddVariableV(p,&x1, "x1", DDS_FLAG_SET, 1.0, NULL,0); /* Register x1 to p. */
    DdsAddVariableV(p,&x2, "x2", DDS_FLAG_SET, 2.0, NULL,0);
    DdsAddVariableV(p,&y,  "y",  DDS_FLAG_REQUIRED, 0.0, CompY,2,x1,x2);
    DdsCompileGraph(p, 0); /* Check relations and determine computation order. */
    DdsComputeStatic(p);   /* Compute variable's value according to defined(by DdsCompileGraph()) order. */
    printf("Value: y=%lf x1=%lf x2=%lf\n",DdsGetValue(y),DdsGetValue(x1),DdsGetValue(x2));
    /* ==&gt; Value: y=0.718282 x1=1.000000 x2=2.000000 */
    DdsDeleteProcessor(&p);
</pre></code>
</td><td>
<code><pre>
   double CompY(DDS_PROCESSOR p, DDS_VARIABLE y)
   {
	DDS_VARIABLE x1 = DdsGetRHSV(y, 0);
	DDS_VARIABLE x2 = DdsGetRHSV(y, 1);
	double xv1 = DdsGetValue(x1);
	double xv2 = DdsGetValue(x2);
	return exp(xv1)-xv2;
   }
</pre></code>
</td></tr>
</table>
<b>Note:</b>Functions used in the example may return non-zero value in case of error,that is ignored to make the example be simple.<p/>

<a href="#DdsAddVariableV">DdsAddVariableV(p,&amp;y,  "y",  DDS_FLAG_REQUIRED, 0.0, CompY,2,x1,x2)</a><br/>
allocates memories of DDS_VARIABLE,sets it's pointer to y,and register the newly allocated variable(y) to the processor p.<br/>
Also DdsAddVariableV() sets flag <a href="#REQUIRED">DDS_FLAG_REQUIRED</a>,value 0.0,function pointer(<b>CompY</b>) to compute the value of y,and right hand side variables x1,x2(2 is the number of right hand side variables, x1,x2), to y. <br/>
<b>Note:</b> Note that right hand side variables x1 and x2 are already registered to p before y is,and have valid address registered to p at this moment.<p/>
The flag <b>DDS_FLAG_REQUIRED</b> is the specification that the value of the variable y is what the user wants to know.<p/>
<b>DdsAddVariableV(p,&amp;x1, "x1", DDS_FLAG_SET, 1.0, NULL,0)</b><br/>
The flag <a href="#SET">DDS_FLAG_SET</a> for x1 and x2 is a constant requirement,and the value specified (1.0 or 2.0) will never be changed even right hand variables are given.<p/>
<a href="#DdsCompileGraph">DdsCompileGraph(p, 0)</a> checks relations and determines computation order,and
<a href="#DdsComputeStatic">DdsComputeStatic(p)</a> simply computes the required value of y.<p/>
Instead of redundancy above,the user will obtain flexibility.<br/>
If the flags are changed to as:
<code><pre>
    DdsAddVariableV(p,&x1, "x1", DDS_FLAG_REQUIRED, 1.0, NULL,0);
    DdsAddVariableV(p,&y,  "y",  DDS_FLAG_TARGETED, 0.0, CompY,2,x1,x2);
    /* ==&gt; Value: y=0.000000 x1=0.693148 x2=2.000000 */
</pre></code>
<a href="#TARGETED">DDS_FLAG_TARGETED</a> means that the value of y is to be 0.0 after computations. And the value of x1,which is not DDS_FLAG_SET this time,will be the value that make the value of y be 0.0.  DDSL creates (non-linear) equation(s) and solves it automatically according to the user's specifications.<p/>
<b>Note:</b> Flags can be freely changed after DdsAddVariableV().

<h3>DDS_FLAG_INTEGRATED and DDS_STEADY_STATE dynamic example</h3>
The next example demonstrates the integration(dynamic) and the computation of <a href="#INTEGRATED">the steady state</a>.
<table width="100%">
<tr><td>
<img src="./i.png">
</td><td>
<code><pre>
	/* dy/dt = A(C-y) + B */
	/* dy/dt(inf)==&gt;0.0, y = (AC+B)/A  */
	/* Steady state y = 5.0 */
	DDS_PROCESSOR p;
	DDS_VARIABLE y, dydt, A,B,C, time, step;
	DDS_VARIABLE* pVs, *pVr;
	int i,j,nv, nr;
	DdsCreateProcessor(&p, 10);
	DdsAddVariableV(p, &A, "A", DDS_FLAG_SET, 1.0, NULL, 0);
	DdsAddVariableV(p, &B, "B", DDS_FLAG_SET, 2.0, NULL, 0);
	DdsAddVariableV(p, &C, "C", DDS_FLAG_SET, 3.0, NULL, 0);
	DdsAddVariableV(p, &y, "y", DDS_FLAG_REQUIRED|DDS_FLAG_INTEGRATED, 1.0, NULL,1, &dydt);
	DdsAddVariableV(p, &dydt, "dy/dt", DDS_FLAG_REQUIRED, 0.0, CompDYDT, 4,&A,&B,&C,&y);
	time = DdsTime(p);
	step = DdsStep(p);
	pVs = DdsGetVariables(&nv, p);
	for (i = 0; i < nv; ++i) {
		pVr = DdsGetRhsvs(&nr, pVs[i]);
		for (j = 0; j < nr; ++j) {
			pVr[j] = *((DDS_VARIABLE*)pVr[j]);
		}
	}
	DdsSetValue(step, 0.1);
	DdsCompileGraph(p, 0);
	for (i = 0; i < 11; ++i) {
		DdsComputeDynamic(p,0);
		printf("Dynamic:Time=%lf dydt=%lf y=%lf\n",
			DdsGetValue(time), DdsGetValue(dydt), DdsGetValue(y));
	}
	DdsCompileGraph(p, DDS_STEADY_STATE);
	DdsComputeStatic(p);
	printf("Steady :Time=%lf dydt=%lf y=%lf\n",
		DdsGetValue(time), DdsGetValue(dydt), DdsGetValue(y));
	DdsDeleteProcessor(&p);
</pre></code>
</td><td>
<code><pre>
double CompDYDT(DDS_PROCESSOR p, DDS_VARIABLE y)
{
	DDS_VARIABLE A = DdsGetRHSV(y, 0);
	DDS_VARIABLE B = DdsGetRHSV(y, 1);
	DDS_VARIABLE C = DdsGetRHSV(y, 2);
	DDS_VARIABLE Y = DdsGetRHSV(y, 3);
	double AV = DdsGetValue(A);
	double BV = DdsGetValue(B);
	double CV = DdsGetValue(C);
	double yv = DdsGetValue(Y);
	return AV*(CV-yv)+BV;
}

/* Computation results 
Dynamic:Time=0.000000 dydt=4.000000 y=1.000000
Dynamic:Time=0.100000 dydt=3.619000 y=1.380650
Dynamic:Time=0.200000 dydt=3.274607 y=1.725071
Dynamic:Time=0.300000 dydt=2.962992 y=2.036717
Dynamic:Time=0.400000 dydt=2.681031 y=2.318706
Dynamic:Time=0.500000 dydt=2.425901 y=2.573860
Dynamic:Time=0.600000 dydt=2.195050 y=2.804734
Dynamic:Time=0.700000 dydt=1.986167 y=3.013638
Dynamic:Time=0.800000 dydt=1.797161 y=3.202662
Dynamic:Time=0.900000 dydt=1.626141 y=3.373699
Dynamic:Time=1.000000 dydt=1.471396 y=3.528459
Steady :Time=1.000000 dydt=0.000000 y=5.000000
*/
</pre></code>
</td></tr>
</table>
<a name="RHSV" />
Any variable including RHSVs of any variable must be registered to the processor before calling <a href="#DdsCompileGraph">DdsCompileGraph()</a>.
But this is sometimes difficult in programing(when <a href="#DdsAddVariableV">DdsAddVariableV()</a> is called),especially the case of loop.<br/>
The following codes(extracted from above) avoid the difficulties by specifying pointers for RHSVs at first,and reset them as follows(see <a href="#API_REF">API references</a>):
<code><pre>
	pVs = DdsGetVariables(&nv, p);
	for (i = 0; i < nv; ++i) {
		pVr = DdsGetRhsvs(&nr, pVs[i]);
		for (j = 0; j < nr; ++j) {
			pVr[j] = *((DDS_VARIABLE*)pVr[j]);
		}
	}
</pre></code>
<b>Note:</b> All RHSVs of any variable are all pointers this time(ex:DdsAddVariableV(p, &amp;dydt, "dy/dt", DDS_FLAG_REQUIRED, 0.0, CompDYDT, 4,<b>&amp;A,&amp;B,&amp;C,&amp;y</b>)).<br/>
<b>Note:</b> DdsAddVariableV() never check any RHSV given(so RHSV can even be NULL). <p/>

<b><a href="#DdsAddVariableV">DdsAddVariableV</a>(p, &y, "y", DDS_FLAG_REQUIRED|DDS_FLAG_INTEGRATED, 1.0, NULL,1, &dydt)</b><br/>
means that the y,which has <a href="#INTEGRATED">DDS_FLAG_INTEGRATED</a> flag,is computed by dydt through integration.<br/>
As is shown in the left image,all variables other than y are computed at the specific time(on the specific time plain).<br/>
y,on the other hand, is computed(integrated) when time is incremented.<br/>


<a href="#DdsComputeDynamic">DdsComputeDynamic(p,0)</a> integrates all variables of DDS_FLAG_INTEGRATED by specified step(<b>1 step</b>), and after integration,
it calls <a href="#DdsComputeStatic">DdsComputeStatic(p)</a> internally and increment the time by specified step.<p/>

<b>Note:</b> DDSL can compute <a href="#INTEGRATED">the steady state</a> by calling <a href="#DdsCompileGraph">DdsCompileGraph(p, DDS_STEADY_STATE)</a>.<br/>
<b>Note:</b> y(=DDS_FLAG_INTEGRATED:&lt;I&gt;) looks like constant(=DDS_FLAG_SET:&lt;S&gt;) from downstream variables of y(see <a href="#FLAG">flags</a>).<br/>
<b>Note:</b> More explanation will be given in detail hearinafter.<p/>


<h3>What the user must do:</h3>
As described so far,the user must invoke:
<ol>
<li><a href="#DdsCreateProcessor">DdsCreateProcessor()</a>...create a processor</li>
<li><a href="#DdsAddVariableV">DdsAddVariableV()</a><br/>
<a href="#DdsAddVariableA">DdsAddVariableA()</a>...create a variable and register it to the processor.
    The user also sets the (initial) value of y,the right hand side variables,and the function to compute the value of y. The user also sets user <a href="#FLAG">FLAG</a>s(attributes) of y that determin the computation order.</li>
<li><a href="#DdsCompileGraph">DdsCompileGraph()</a>... checks relations of each variable and determines computation order.</li>
<li><a href="#DdsComputeStatic">DdsComputeStatic()</a> or<br/> 
<a href="#DdsComputeDynamic">DdsComputeDynamic()</a>... compute variable's value by solving non-linear equations or ordinary differential equations,according to the computation order determined by DdsCompileGraph().</li>
<li><a href="#DdsDeleteProcessor">DdsDeleteProcessor()</a>... frees every memories allocated by the processor.</li>
</ol>

<h3>What DDSL can do:</h3>
DDSL can:
<ol>
<li>remove variables having <b>no contribution</b> directly or indirectly for computing variables of <a href="#REQUIRED">DDS_FLAG_REQUIRED</a> from any computation.</li>
<li>automatically detect <a href="#DIVISIBLE">loop</a> such as y=f(y),and rearrange it to the equation system as y2 = y1 - f(y1), y2 ==&gt;0.0</li> 
<li>automatically construct <a href="#TRIANGULAR">non-linear eqution sysytems</a> and solve them.</li>
<li>construct <a href="#DdsGetVariableSequence">computation order</a> of each variable.</li>
<li>solve <a href="#INTEGRATED">ordinally differential equations</a> if given.</li>
<li>obtain <a href="#INTEGRATED">steady state</a> by changing ordinally differential equations to algebraic equation systems and solve them.</li>
</ol>
How DDSL realizes these will be hereinafter described.

<a name="FLAG" />
<h2>Flags(Attributes)</h2>
<table><tr><td><a href="#UFLAG"> User flags </a></td><td><a href="#SFLAG"> System flags </a></td><td><a href="#TRIANGULAR">Block triangular decomposition</a></td></tr></table>
The flags or attributes (see ddsl.h) are the most impotant part. A variable has two <b>32-bit unsigned int</b> element for <b>user's flags</b> and <b>system's flags</b>. User's flags are controled by the user and DDSL never change them. One flag occupies 1-bit of 32-bit unsigned integer which can be set or reset. DDSL checks user's flags and copies them to system's if they are correct. DDSL controls(set or reset) system's flag during the processing.<br/>
More than one flags can be specified as:<br/>
<pre><code>
    DdsAddVariableV(p,&x2, "x2", DDS_FLAG_SET|DDS_FLAG_VOLATILE, 2.0, NULL,0);
</code></pre>
or
<pre><code>
    DdsSetUserFlag(x2,DDS_FLAG_SET|DDS_FLAG_VOLATILE);
</code></pre>

<a name="UFLAG"/>
<h3>User flags:</h3>
<table width="100%"><tr><td>
<a href="#REQUIRED">DDS_FLAG_REQUIRED</a></td><td><a href="#SET">DDS_FLAG_SET</a></td><td><a href="#TARGETED">DDS_FLAG_TARGETED</a></td><td><a href="#INTEGRATED">DDS_FLAG_INTEGRATED</a></td></tr><tr><td><a href="#VOLATILE">DDS_FLAG_VOLATILE</a></td><td><a href="#DIVISIBLE">DDS_FLAG_DIVISIBLE</a></td><td><a href="#NON_DIVISIBLE">DDS_FLAG_NON_DIVISIBLE</a>
</td><td> </td></tr></table>
<b>Note:</b> All user flags use lower 12-bit of unsigned int,thus,upper 20-bit can be freely used by the user.
<p/>
<a name="REQUIRED"/>
<table border="1" width="100%">
<col width="75%">
<tr><th align="left">User flag name (notation)</th><th align="left">value</th>
<tr><td><b>DDS_FLAG_REQUIRED (&lt;R&gt;)</b></td><td>0x00000001</td></tr>
</table>
The user must set this flag to any variable of which value is wanted.<br/>
<b>If there is no variable of &lt;R&gt; flag,then nothing is computed.</b>
<p/>
<a name="SET"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_FLAG_SET (&lt;S&gt;)</b></td><td>0x00000002</td></tr></table>
<table width="100%" border="1">
<tr><td><img src="./s.png"></td><td align="left">
&lt;S&gt; is a constant specification.<br/>
Any variable having this flag is never computed even RHSVs and the function to compute its value are defined.<br/>This specification may cause to divide one connected component into more than one.
</td></tr>
</table>
<b>Note:</b><b>Connected component</b> is a group of variables that are connected directly or indirectly each other.
<p/>

<a name="TARGETED"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_FLAG_TARGETED (&lt;T&gt;)</b></td><td>0x00000004</td></tr>
</table>
<table width="100%" border="1">
<col width="25%"><col width="60%">
<tr><td><img src="./t.png"></td><td align="left">
The value of &lt;T&gt; variable becomes specified value by computation.<br/>
The variable which can freely change it's value(<a href="#FREE">&lt;F&gt;</a>(detected by DDSL) variable which has no RHSVs and not &lt;S&gt;) must exist on the upstream of &lt;T&gt;. 
The value of <a href="#FREE">&lt;F&gt;</a> variable will be adjusted to make the value of &lt;T&gt; be the specified value. 
The (computed) value of &lt;T&gt; variable becomes the specified value by solving non-linear equation: y<sub>&lt;T&gt;</sub> = f(x<sub>&lt;F&gt;</sub>).<p/>
<b>Solvability conditions on non-linear equation systems(checked by DDSL):</b>
<ol>
<li>Number of &lt;T&gt;s and <a href="#FREE">&lt;F&gt;</a>s must be equal in the same connected component.</li>
<li>Independen route from each <a href="#FREE">&lt;F&gt;</a> to &lt;T&gt; must exist(1 to 1 matching of <a href="#FREE">&lt;F&gt;</a> and &lt;T&gt;).</li>
</ol>
<b>Note:</b> The value of <a href="#FREE">&lt;F&gt;</a> before computation will be used as an initial value.<br/>
<b>Note:</b> N-&lt;T&gt;s(N-<a href="#FREE">&lt;F&gt;</a>s) construct N-dimensional equation system in general(<a href="#TRIANGULAR">can be reduced if possible</a>) if they are mutually connected.<p/>
From downstream variables,&lt;T&gt; look like &lt;S&gt;. <br/>
This specification may cause to divide one connected component into more than one.
</td><td>
<img src="./ft_route.png"><br/>
This looks to be 2-dimensional equation system because there are two <a href="#FREE">&lt;F&gt;</a>s and two &lt;T&gt;s. 
But,the independent 2 routes from each <a href="#FREE">&lt;F&gt;</a> to &lt;T&gt; can not be found that means the equation system can not be solved which is detected before actual computations(DDSL checks this condition).
</td></tr>
</table>
<p/>
<a name="DIVISIBLE"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_FLAG_DIVISIBLE (&lt;D&gt;)</b></td><td>0x00000020</td></tr></table>
<table width="100%" border="1">
<tr><td><img src="./loop.png"></td><td align="left">
Any variable(say y) computed by itself like y = f(y) constructs a loop. 
It is necessary to divide y ( y ==&gt; y1 , y2 ) to compute value of the variables on the loop.
If y is divided into y1(=<a href="#FREE">&lt;F&gt;</a>) and y2(=<a href="#TARGETED">&lt;T&gt;</a>),then a new equation <br/>
  y2 = y1 - f(y1)<br/>
  y2==&gt;0.0<br>
will be added and be solved.<br/>
y1 is &lt;F&gt; and y2 is &lt;T&gt;.also both y1 and y2 are <a href="#DIVIDED">&lt;DD&gt;</a> at the same time.<p/>
DDSL automatically detects loops and performs above procedures.<br/>
Any variable on a loop can be divided. The user can specify this &lt;D&gt;(DDS_FLAG_DIVISIBLE) flag on any variable(by reason of easy estimation of initial value, etc.) to be divided. DDSL tries to divide &lt;D&gt; varable,but it is not alway divided.
DDSL finds loops and tries to divide the variable which is located on more loops.
The variable actually divided will have the system flag <a href="#DIVIDED">DDS_SFLAG_DIVIDED(&lt;DD&gt;)</a>.<p/>
<b>Note:</b> &lt;D&gt; variable is not alway divided.<br/>
<b>Note:</b> The y1 is the same as y,and newly created variable y2 has the name of y+'+'.
</td></tr>
</table>
<p/>
<a name="NON_DIVISIBLE"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_FLAG_NON_DIVISIBLE (&lt;N&gt;)</b></td><td>0x00000040</td></tr>
</table>
This flag is set on the variable which the user do not want to be divided.
DDSL tries not to divide the variable of this flag,but it is not alway true due to <a href="#DIVISIBLE">above reason</a>.<p/>

<a name="INTEGRATED"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_FLAG_INTEGRATED (&lt;I&gt;)</b></td><td>0x00000008</td></tr></table>
Integration specification. &lt;I&gt; variable's value is computed by integration. &lt;I&gt; must have only 1 RHSV which is the derivative(<a href="#DERIVATIVE">&lt;DR&gt;</a>)of the ordinary differential equation. The function pointer to compute(integrate) the value of &lt;I&gt; is not necessary because integration methods such as Euler,Backward Euler,and Runge-Kutta methods are built in.
<p/>
<b>Steady state computation:</b>
<blockquote>The steady state,if exists,can be obtained to keep integration which is,althogh,time consuming.<p/>
DDSL can algebraicaly compute the steady state as:
<ol>
<li>Change &lt;I&gt variables to &lt;F&gt.</li>
<li>Change &lt;DR&gt variables to &lt;T&gt of value 0.0(steady state condition).</li>
<li>Solve non-linear equation systems to find the value of &lt;I&gt;s that make all value of <a href="#DERIVATIVE">&lt;DR&gt;</a>s be zero(steady state).</li>
</ol>
See: <a href="#DdsCompileGraph">DdsCompileGraph(p,DDS_STEADY_STATE)</a>
</blockquote>
<a name="VOLATILE"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_FLAG_VOLATILE (&lt;V&gt;)</b></td><td>0x00000010</td></tr></table>
&lt;V&gt; flag can only be set on the variable of &lt;S&gt; or &lt;T&gt;.<br/>
&lt;V&gt; flag means that the value of &lt;V&gt; is outside the control of DDSL(&lt;V&gt; treated as &lt;S&gt; or &lt;T&gt;,but it's value is undefined).<br/>
&lt;V&gt; variables are regarded as time-dependent variables.

<a name="TRIANGULAR" />
<h3>Block triangular decomposition</h3>
<table border="1" width="100%">
<col width="30%">
<tr><td>
<img src="./block.png">
</td><td>
Newton method creates Jacobian matrix when it solves non-linear equation system (y=f(x) ==&gt;0.0),<blockquote>
y(x+dx) = y(x)+J*dx ==&gt; 0.0 ,  <br/>
then dx = -J<sup>-1</sup>*y(x),
</blockquote>
where J is a Jacobian matrix(=dy/dx), y,x,and dx are vectors,and x+dx is the next estimation.<br/>
Computation of J or J<sup>-1</sup> may be time-consuming if J is quite large.<br/>
DDSL divides,if possible,J into a sequence of small-sized matrices as shown in the left image which is called as <b>Block Triangular Decomposition</b>.<br/>
In the left image,instead of solving big J,smaller sized matrices (1),(2),and (3) are solved in this order by re-arranging columns and rows,<br>
DDSL adopts numerical differentiation,so that the user need not to prepaire any equations to compute the Jacobian-matrix(dy/dx).<br/>
</td></tr>
</table>

<a name="SFLAG" />
<h3>Systems flags:</h3>
<table width="100%"><tr><td>
<a href="#ALIVE">DDS_SFLAG_ALIVE</a></td><td><a href="#FREE">DDS_SFLAG_FREE</a></td><td><a href="#DIVIDED">DDS_SFLAG_DIVIDED</a></td><td><a href="#DERIVATIVE">DDS_SFLAG_DERIVATIVE</a></td></tr><tr><td><a href="#ERROR">DDS_SFLAG_ERROR</a></td><td><a href="#ONCE">DDS_COMPUTED_ONCE</a></td><td><a href="#EVERY_TIME">DDS_COMPUTED_EVERY_TIME</a></td><td><a href="#ANY_TIME">DDS_COMPUTED_ANY_TIME</a>
</td></tr></table>
<p/>
As descrived before,DDSL copies user flags to system flag area after checking,and adds or changes them during the processing(DDSL never touch user flag area which is unsigned int).Typical system flags are listed and described here.<p/>
<a name="ALIVE"/>
<table border="1" width="100%">
<col width="75%">
<tr><th align="left">System flag name (notation)</th><th align="left">value</th>
<tr><td><b>DDS_SFLAG_ALIVE (&lt;AL&gt;)</b></td><td>0x00001000</td></tr></table>
Any variable which has,directly or indirectly,any contribution to compute &lt;R&gt; variables will be &lt;AL&gt;(variable aliving).<br/>
On the other hand,variables not &lt;AL&gt; will be removed from any computation.
<p/>
<a name="FREE"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_SFLAG_FREE (&lt;F&gt;)</b></td><td>0x00002000</td></tr></table>
DDSL finds and sets &lt;F&gt;flag on the variable which has no RHSV and not &lt;S&gt;.<br/>
&lt;F&gt; variables will be independent(because it can freely change it's value) variables of non-linear eqution systems.<br/>
Corresponding dependent variables are <a href="#TARGETED">&lt;T&gt;s</a>(that must have &lt;F&gt;s on their upstream).<p/>
<b>Note:</b> Total number of &lt;F&gt;s and &lt;T&gt;s must be equal in the same connected component.<br/>
<b>Note:</b> Independent route from each &lt;F&gt; to &lt;T&gt; must exist.
<p/>
<a name="DIVIDED"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_SFLAG_DIVIDED (&lt;DD&gt;)</b></td><td>0x00004000</td></tr></table>
<a href="#DIVISIBLE">DDSL detects a loop and divide a variable on the loop</a>. <br/>
Dividing a variable means that one more variable is created(and registered to the processor).<br/>
The variable before divided is changed to &lt;F&gt;(and is &lt;DD&gt; at the same time),and the newly
created variable is &lt;T&gt;(and also is &lt;DD&gt; at the same time).
<p/>
<a name="DERIVATIVE"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_SFLAG_DERIVATIVE (&lt;DR&gt;)</b></td><td>0x00008000</td></tr></table>
&lt;DR&gt; is the RHSV of &lt;I&gt; and is the derivative of the &lt;I&gt;.<br/>
<a href="#INTEGRATED">On steady state computation</a>,&lt;DR&gt; will be changed to &lt;T&gt; of the value 0.0 (&lt;I&gt; will be changed to &lt;F&gt; at the same time).
<p/>
<a name="ERROR"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_SFLAG_ERROR (&lt;ER&gt;)</b></td><td>0x00010000</td></tr></table>
When combination of user flags have any error,then this flag will be set to the system flag.
<p/> 
<a name="ONCE"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_COMPUTED_ONCE (&lt;1T&gt;)</b></td><td>0x00020000</td></tr></table>
Any variable which is computed only by non-<a href="#VOLATILE">volatile</a> &lt;S&gt; or non-volatile &lt;T&gt; directly or indirectly.
Once &lt;1T&gt; is computed then it's value is unchanged.
<br/><b>Note:</b> <a href="#DdsGetVariableSequence">See DdsGetVariableSequence()</a><p/>
<a name="EVERY_TIME"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_COMPUTED_EVERY_TIME (&lt;ET&gt;)</b></td><td>0x00040000</td></tr></table>
&lt;ET&gt; variable is computed at every integration step. &lt;ET&gt; variable is also on the route from &lt;I&gt; to &lt;DR&gt;.
<br/><b>Note:</b> <a href="#DdsGetVariableSequence">See DdsGetVariableSequence()</a><p/>
<a name="ANY_TIME"/>
<table border="1" width="100%">
<col width="75%">
<tr><td><b>DDS_COMPUTED_ANY_TIME (&lt;AT&gt;)</b></td><td>0x00080000</td></tr></table>
&lt;AT&gt; variable is time dependent but is not necessary to be computed at every integration step.
If the user wants to know the value of &lt;AT&gt; variable,user must call <a href="#DdsComputeStatic">DdsComputeStatic()</a> after <a href="#DdsComputeDynamic">DdsComputeDynamic()</a>.
<br/><b>Note:</b> <a href="#DdsGetVariableSequence">See DdsGetVariableSequence()</a><p/>

<a name="API_REF" />
<h2>API references</h2>
<table width="100%">
<tr><th>Basic Processor Functions</th><th>Basic Variable Functions</th><th>Service Functions</th><th>Low Level Functions</th></tr><tr>
<td>
<a href="#DdsCreateProcessor">DdsCreateProcessor</a><br/>
<a href="#DdsDeleteProcessor">DdsDeleteProcessor</a><br/>
<a href="#DdsAddVariableV">DdsAddVariableV</a><br/>
<a href="#DdsAddVariableA">DdsAddVariableA</a><br/>
<a href="#DdsCompileGraph">DdsCompileGraph</a><br/>
<a href="#DdsComputeStatic">DdsComputeStatic</a><br/>
<a href="#DdsComputeDynamic">DdsComputeDynamic</a><br/>
<a href="#DdsGetVariables">DdsGetVariables</a><br/>
<a href="#DdsTime">DdsTime</a><br/>
<a href="#DdsStep">DdsStep</a><br/>
<a href="#DdsGetVariableSequence">DdsGetVariableSequence</a><br/>
<a href="#DdsSetErrorHandler">DdsSetErrorHandler</a><br/>
<a href="#DdsGetErrorHandler">DdsGetErrorHandler</a><br/>

</td><td>
<a href="#DdsGetVariableName">DdsGetVariableName</a><br/>
<a href="#DdsGetValue">DdsGetValue</a><br/>
<a href="#DdsSetValue">DdsSetValue</a><br/>
<a href="#DdsGetRhsvs">DdsGetRhsvs</a><br/>
<a href="#DdsSetRHSV">DdsSetRHSV</a><br/>
<a href="#DdsGetRHSV">DdsGetRHSV</a><br/>
<a href="#DdsGetUserFlag">DdsGetUserFlag</a><br/>
<a href="#DdsSetUserFlag">DdsSetUserFlag</a><br/>
<a href="#DdsGetSystemFlag">DdsGetSystemFlag</a><br/>
<a href="#DdsSetUserFlagOn"> DdsSetUserFlagOn</a><br/>
<a href="#DdsSetUserFlagOff">DdsSetUserFlagOff</a><br/>
</td><td>
<a href="#DdsGetEPS">DdsGetEPS</a><br/>
<a href="#DdsSetEPS">DdsSetEPS</a><br/>
<a href="#DdsGetMaxIterations">DdsGetMaxIterations</a><br/>
<a href="#DdsSetMaxIterations">DdsSetMaxIterations</a><br/>
<a href="#DdsGetProcessorUserPTR">DdsGetProcessorUserPTR</a><br/>
<a href="#DdsSetProcessorUserPTR">DdsSetProcessorUserPTR</a><br/>
<a href="#DdsGetVariableUserPTR">DdsGetVariableUserPTR</a><br/>
<a href="#DdsSetVariableUserPTR">DdsSetVariableUserPTR</a><br/>
<a href="#DdsCheckVariable">DdsCheckVariable</a><br/>
<a href="#DdsDbgPrintF">DdsDbgPrintF</a><br/>
</td><td>
<a href="#DdsGetVariableNext">DdsGetVariableNext</a><br/>
<a href="#DdsGetVariableIndex">DdsGetVariableIndex</a><br/>
<a href="#DdsGetVariableScore">DdsGetVariableScore</a><br/>
<a href="#DdsSieveVariable">DdsSieveVariable</a><br/>
<a href="#DdsDivideLoop">DdsDivideLoop</a><br/>
<a href="#DdsCheckRouteFT">DdsCheckRouteFT</a><br/>
<a href="#DdsBuildSequence">DdsBuildSequence</a><br/>
</td></tr>
</table>

<p/>
<a name="DdsCreateProcessor"/>
<table width="100%" border="1">
<col width="10%">
<tr><th>Return value</th><th>Function name(arguments...)</th></tr>
<tr><td>int</td><td>DdsCreateProcessor(DDS_PROCESSOR* p, int nv)</td></tr>
</table>
DdsCreateProcessor() allocates memories of DDS_PROCESSOR (struct defined ddsl.h) and sets it's pointer to the first argument <b>p</b>.<br/>
The second argument <b>nv</b> is the number of variables the processor <b>p</b> can keep which will be extended automaticaly if more than <b>nv</b> variables are to be added.<br/>
<b>Note:</b> This function returns 0 if it normally finishes,otherwise it returns non-zero error value(see error code listed in ddsl.h).
<p/>

<a name="DdsDeleteProcessor"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>void</td><td>DdsDeleteProcessor(DDS_PROCESSOR* p)</td></tr>
</table>
DdsDeleteProcessor() frees all memories the processor <b>p</b> allocated. <br/>
And sets <b>p</b> be NULL.<br/>
<p/>
<a name="DdsAddVariableV"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsAddVariableV(DDS_PROCESSOR p,DDS_VARIABLE *pv,const char *name,unsigned int f,double val, ComputeVal func,int nr,...)</td></tr>
</table>
DdsAddVariableV() allocates memories of DDS_VARIABLE (struct defined in ddsl.h) and sets it's pointer to <b>pv</b>.<br/>
And register newly created variable to the processor <b>p</b>.
[Arguments]
<ul>
<li> p  ... DDS_PROCESSOR created by <a href="#DdsCreateProcessor">DdsCreateProcessor()</a> beforehand.</li>
<li> pv ... Pointer to DDS_VARIABLE which is set if the memories are normaly allocated.</li>
<li> name ... Character string of the name of the newly allocated variable pv.</li>
<li> f ... <a href="#FLAG">User flags</a> set to pv.</li>
<li> val ... (Initial) value of the variable pv.</li>
<li> func ... Function pointer to compute the value of the variable pv(about ComputeVal,see ddsl.h)</li>
<li> nr,... nr is the number of RHSVs of the variable pv. After nr,nr RHSVs follow. ... means the variable argument list of RHSVs.</li>
<li> ...,...  List of nr RHSVs. </li>

</ul>
<b>Note:</b> The last nr RHSVs of pv's can be anything(can be NULL) at this moment. DDSL allocates the memories for them and just stores them(<a href="#RHSV">see</a>).
<br/>
<b>Note:</b> This function returns 0 if it normally finishes,otherwise it returns non-zero error value(see error code listed in ddsl.h).
<p/>

<p/>
<a name="DdsAddVariableA"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsAddVariableA(DDS_PROCESSOR p, DDS_VARIABLE* pv, const char* name, unsigned int f, double val, ComputeVal func, int nr, DDS_VARIABLE* rhsvs)</td></tr>
</table>
DdsAddVariableA() is almost the same as <a href="#DdsAddVariableV">DdsAddVariableV()</a> above except for the last argument.<br/>
The last argument of DdsAddVariableA() is an array of RHSVs of size nr.
<br/>
<b>Note:</b> This function returns 0 if it normally finishes,otherwise it returns non-zero error value(see error code listed in ddsl.h).
<p/>

<a name="DdsCompileGraph"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsCompileGraph(DDS_PROCESSOR p,int method)</td></tr>
</table>
DdsCompileGraph() calls following functions in this order and build up everything necessary before computation.
<ol>
<li><a href="#DdsSieveVariable">DdsSieveVariable(p)</a>... copies correct user flags to system flag,and selects <a href="#ALIVE">&lt;AL&gt;</a> variables.</li>
<li><a href="#DdsDivideLoop">DdsDivideLoop(p)</a>... detects loops and divide them into <a href="#DIVISIBLE">&lt;DD&gt;</a>.</li>
<li><a href="#DdsCheckRouteFT">DdsCheckRouteFT(p)</a>...checks <a href="#TARGETED">1 to 1 correspondense between &lt;F&gt;s and &lt;T&gt;s</a>,and performs <a href="#TRIANGULAR">block triangular decomposition</a>.</li>
<li><a href="#DdsBuildSequence">DdsBuildSequence(p)</a>... constructs conputation order.</li>
</ol>
DdsCompileGraph() also divide all variables computed into 3 groups(<a href="#DdsBuildSequence">DdsBuildSequence(p)</a>) as:
<ul>
<li><a href="#ONCE">DDS_COMPUTED_ONCE (&lt;1T&gt;)</a>: Variables computed once that are computed directly or indirectly only by non-volatile &lt;S&gt; or &lt;T&gt;.</li>
<li><a href="#EVERY_TIME">DDS_COMPUTED_EVERY_TIME (&lt;ET&gt;)</a>: Variables computed at every integration steps that are on the route from &lt;I&gt; to &lt;DR&gt;.</li>
<li><a href="#EVERY_TIME">DDS_COMPUTED_ANY_TIME (&lt;AT&gt;)</a>: Variables computed at any time that are time dependent but are not (&lt;ET&gt;).
</ul>

The method must be 0(default:DDS_I_RUNGE_KUTTA) or the one listed bellow:
<ul>
<li>DDS_I_EULER or DDS_I_RUNGE_KUTTA  ... Euler or Runge-Kutta method for integration(DdsComputeDynamic(p) must be called next).</li>
<li>DDS_I_BW_EULER  ... Backward Euler method for integration(DdsComputeDynamic(p) must be called next).</li>
<li>DDS_STEADY_STATE ... Steady state computation(DdsComputeStatic(p) should be called next).</li>
</ul>
The computation order changes according to integration methods or steady state computation.
<p/>
<b>Note:</b> This function returns 0 if it normally finishes,otherwise it returns non-zero error value(see error code listed in ddsl.h).
<p/>

<a name="DdsComputeStatic"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsComputeStatic(DDS_PROCESSOR p)</td></tr>
</table>
DdsComputeStatic() computes value of variables at specific time,solves non-linear equation systems if given.
<br/>
<b>Note:</b> This function returns 0 if it normally finishes,otherwise it returns non-zero error value(see error code listed in ddsl.h).
<p/>

<a name="DdsComputeDynamic"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsComputeDynamic(DDS_PROCESSOR p,int method)</td></tr>
</table>
DdsComputeDynamic() solves(<b>1 step</b> of) ordinaly differential equations by specified integration method(Euler,Backword Euler,or Runge-Kutta method).<br/>
DdsComputeDynamic() performs processes in the following order:
<ol>
<li>DdsComputeDynamic() calls DdsComputeStatic() at t(=<a href="#DdsTime">current time</a>),if necessary.</li>
<li>Suppose y is an <a href="#INTEGRATED">&lt;I&gt;</a>,then the value y(t+dt) is computed by integration(t is <a href="#DdsTime">the current time</a> and dt is <a href="#DdsStep">the time step</a>).</li>
<li>DdsComputeDynamic(),then,calls <a href="#DdsComputeStatic">DdsComputeStatic()</a> to compute the value of any other time dependent variables(see: <a href="#DdsGetVariableSequence">DdsGetVariableSequence(p,DDS_COMPUTED_EVERY_TIME)</a> at time t+dt,and increments time = t + dt.</li>
</ol>
<b>method</b> can be 0(default), DDS_I_EULER, or DDS_I_RUNGE_KUTTA.<blockquote>
DDS_I_EULER or DDS_I_RUNGE_KUTTA can be specified only when the second argument of <a href="#DdsCompileGraph">DdsCompileGraph()</a> is the one of DDS_I_EULER or DDS_I_RUNGE_KUTTA(mutualy exchangeable).
</blockquote>
<b>Note:</b> To increment <a href="#DdsTime">Time</a> automaticaly,the value of <a href="#DdsStep">Step</a> must be defined beforehand.<br/>
<b>Note:</b> This function returns 0 if it normally finishes,otherwise it returns non-zero error value(see error code listed in ddsl.h).
<p/>

<a name="DdsTime"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>DDS_VARIABLE</td><td>DdsTime(DDS_PROCESSOR p)</td></tr>
</table>
DdsTime() returns the builtin variable of which name is "#TIME" representing the global time.<br/>
The initial value is 0.0,and is automaticaly incremented by <a href="#DdsComputeDynamic">DdsComputeDynamic()</a>
<p/>
<a name="DdsStep"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>DDS_VARIABLE</td><td>DdsStep(DDS_PROCESSOR p)</td></tr>
</table>
DdsStep() returns the builtin variable of which name is "#STEP" representing the global time step.<br/>
The initial value is 0.0. User must define proper value of this before calling 
<a href="#DdsComputeDynamic">DdsComputeDynamic()</a>(see <a href="#DdsSetValue">DdsSetValue()</a>).
<p/>
<a name="DdsGetUserFlag"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>unsigned int</td><td>DdsGetUserFlag(DDS_VARIABLE v)</td></tr>
</table>
DdsGetUserFlag() returns <a href="#FLAG">every user flags</a>.
<p/>
<a name="DdsSetUserFlag"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>unsigned int</td><td>DdsSetUserFlag(DDS_VARIABLE v,unsigned int f)</td></tr>
</table>
DdsSetUserFlag() replaces <a href="#FLAG">every user flags</a> by f and returns f it self.
<p/>

<a name="DdsGetSystemFlag"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>unsigned int</td><td>DdsGetSystemFlag(DDS_VARIABLE v)</td></tr>
</table>
DdsGetSystemFlag() returns <a href="#SFLAG">every system flags</a>.
<p/>

<a name="DdsSetUserFlagOn"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>unsigned int</td><td>DdsSetUserFlagOn(DDS_VARIABLE v, unsigned int f)</td></tr>
</table>
DdsSetUserFlagOn() sets user flags specified by f be on as.<br/>
<b>F |= f</b><br/>
where F is the user flags.
<p/>

<a name="DdsSetUserFlagOff"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>unsigned int</td><td>DdsSetUserFlagOff(DDS_VARIABLE v, unsigned int f)</td></tr></table>
DdsSetUserFlagOff() sets user flags specified by f be off as.<br/>
  <b>F &= <sup>~</sup>(f)</b><br/>
where F is the user flags.
<p/>

<a name="DdsGetVariables"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>DDS_VARIABLE*</td><td>DdsGetVariables(int* nv, DDS_PROCESSOR p)</td></tr>
</table>
DdsGetVariables() returns the array of all variables registered to the processor p.<br/>
nv is the array size.
<p>

<a name="DdsGetVariableUserPTR"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>void*</td><td>DdsGetVariableUserPTR(DDS_VARIABLE v)</td></tr>
</table>
DdsGetVariableUserPTR() returns the pointer(void*) set to v  by the user.
The usage of the pointer is decided by the user,DDS never touch this.
<p/>

<a name="DdsSetVariableUserPTR"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>void</td><td>DdsSetVariableUserPTR(DDS_VARIABLE v, void* val)</td></tr>
</table>
DdsSetVariableUserPTR() sets the pointer(void*) val to to v.
The usage of the pointer is decided by the user,DDS never touch this.
<p/>
<a name="DdsGetVariableName"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>const char*</td><td>DdsGetVariableName(DDS_VARIABLE v)</td></tr>
</table>
DdsGetVariableName() returns the name of the variable v.
<p/>

<a name="DdsGetValue"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>double</td><td>DdsGetValue(DDS_VARIABLE v)</td></tr>
</table>
DdsGetValue() returns the value of y.
<p/>
<a name="DdsSetValue"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>double</td><td>DdsSetValue(DDS_VARIABLE v,double val)</td></tr>
</table>
DdsSetValue() sets the value of y to val.
<p/>

<a name="DdsGetRhsvs"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>DDS_VARIABLE*</td><td>DdsGetRhsvs(int* nr, DDS_VARIABLE v)</td></tr>
</table>
DdsGetRhsvs() returns the array of all right hand side variables registered to the variable v.<pr/>
nr is the number of the right hand side variables of v(array size).
<p/>
<a name="DdsSetRHSV"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsSetRHSV(DDS_VARIABLE v, int i, DDS_VARIABLE rv)</td></tr>
</table>
DdsSetRHSV() sets i-th right hand side variable of v be rv.
<p/>
<a name="DdsGetRHSV"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>DDS_VARIABLE</td><td>DdsGetRHSV(DDS_VARIABLE v, int i)</td></tr>
</table>
DdsGetRHSV() returns i-th right hand side variable of v.
<p/>
<a name="DdsGetVariableSequence"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>DDS_VARIABLE</td><td>DdsGetVariableSequence(DDS_PROCESSOR p, unsigned int seq)</td></tr>
</table>
DDS determines computation order of each variable(see <a href="#DdsCompileGraph">DdsCompileGraph()</a>).<br/>
DDS(<a href="#DdsCompileGraph">DdsCompileGraph()</a>) also make group of variables in which variables are linked according to the computation order as:
<ol>
<li><b><a href="#ONCE">DDS_COMPUTED_ONCE</a>:</b> Variable in this group is computed at once at the beginning and remain unchanged.</li>
<li><b><a href="#EVERY_TIME">DDS_COMPUTED_EVERY_TIME</a>:</b> Variable in this group is computed at every time step.</li>
<li><b><a href="#ANY_TIME">DDS_COMPUTED_ANY_TIME</a>:</b> Variable in this group is computed(by <a href="#DdsComputeStatic">DdsComputeStatic()</a>) at any time after <a href="#DdsComputeDynamic">DdsComputeDynamic()</a>.</li>
</ol>
According to the computation order,variables in above group can be listed like as follows.<br/>
The argument seq must be the one listed above.:
<pre><code>
  DDS_VARIABLE v = DdsGetVariableSequence(p,DDS_COMPUTED_ONCE);
  /* The order of variables computed at DDS_COMPUTED_ONCE */
  while(v != NULL) {
     printf(" Name=%s\n",DdsGetVariableName(v);
     v = DdsGetVariableNext(v);
  }
</code></pre> 

<a name="DdsGetErrorHandler" />
<table width="100%" border="1">
<col width="10%">
<tr><td>ErrHandler</td><td>DdsGetErrorHandler(DDS_PROCESSOR p)</td></tr>
</table>
DdsGetErrorHandler() returns ErrorHandler if registered to the processor p.<br/>
The user can obtain some error informations through this function on error(see ddsl.h).
<p/>
<a name="DdsSetErrorHandler" />
<table width="100%" border="1">
<col width="10%">
<tr><td>void</td><td>DdsSetErrorHandler(DDS_PROCESSOR p, ErrHandler handler)</td></tr>
</table>
DdsSetErrorHandler() sets ErrorHandler(handler) to the processor p.<br/>
The user can obtain some error informations through this function on error(see ddsl.h).
<p/>

<a name="DdsGetEPS"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>double</td><td>DdsGetEPS(DDS_PROCESSOR p)</td></tr>
</table>
DdsGetEPS() returns convergence criteria for solving non-linear equation systems.
<p/>
<a name="DdsSetEPS"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>double</td><td>DdsSetEPS(DDS_PROCESSOR p, double eps)</td></tr>
</table>
DdsSetEPS() sets convergence criteria to eps for solving non-linear equation systems.
<p/>

<a name="DdsGetMaxIterations"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsGetMaxIterations(DDS_PROCESSOR p)</td></tr>
</table>
DdsGetMaxIterations() returns the maximum iteration count for solving non-linear equation systems.
<p/>

<a name="DdsSetMaxIterations"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsSetMaxIterations(DDS_PROCESSOR p, int max)</td></tr>
</table>
DdsSetMaxIterations() sets the maximum iteration count to max for solving non-linear equation systems.
<p/>
<a name="DdsGetProcessorUserPTR"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>void*</td><td>DdsGetProcessorUserPTR(DDS_PROCESSOR p)</td></tr>
</table>
DdsGetProcessorUserPTR() returns the pointer(void*) set by the user.
The usage of the pointer is decided by the user,DDS never touch this.
<p/>
<a name="DdsSetProcessorUserPTR"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>void</td><td>DdsSetProcessorUserPTR(DDS_PROCESSOR p,void* val)</td></tr>
</table>
DdsSetProcessorUserPTR() sets the pointer(void*) val to to p.
The usage of the pointer is decided by the user,DDS never touch this.
<p/>

<a name="DdsCheckVariable"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsCheckVariable(DDS_PROCESSOR p, DDS_VARIABLE hv)</td></tr>
</table>
DdsCheckVariable() checks the validity of the variables registered to p,varidity of user flags for instance.<br/>
If any error is found,then <a href="#SFLAG_ERROR">DDS_SFLAG_ERROR</a> is set to the variable of error.<br/>
DdsCheckVariable() returns non-zero value when any error is detected.
<p/>
<a name="DdsDbgPrintF"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>void</td><td>DdsDbgPrintF(FILE* f, const char* title, DDS_PROCESSOR p)</td></tr>
</table>
DdsDbgPrintF() outputs current variable informations to f.<br/>
For details,see the souce code ddsl.cpp.
<p/>
<a name="DdsGetVariableNext"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>DDS_VARIABLE</td><td>DdsGetVariableNext(DDS_VARIABLE v)</td></tr>
</table>
DdsGetVariableNext() returns 'NEXT' variable.<br/>
Each variables has a link to the next variable of which usage depends on the process context.
<p/>
<a name="DdsGetVariableIndex"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsGetVariableIndex(DDS_VARIABLE v)</td></tr>
</table>
DdsGetVariableIndex() returns 'INDEX' which is an integer.<br/>
Each variables has a integer value of which usage depends on the process context.
<p/>

<a name="DdsGetVariableScore"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsGetVariableScore(DDS_VARIABLE v)</td></tr>
</table>
Each variables has one more integer value of which usage also depends on the process context.
<p/>
<a name="DdsSieveVariable"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsSieveVariable(DDS_PROCESSOR p)</td></tr>
</table>
See <A href="#DdsCompileGraph">DdsCompileGraph()</a> source code.
<p/>
<a name="DdsDivideLoop"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsDivideLoop(DDS_PROCESSOR p)</td></tr>
</table>
See <A href="#DdsCompileGraph">DdsCompileGraph()</a> source code.
<p/>

<a name="DdsCheckRouteFT"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsCheckRouteFT(DDS_PROCESSOR p)</td></tr>
</table>
See <A href="#DdsCompileGraph">DdsCompileGraph()</a> source code.
<p/>

<a name="DdsBuildSequence"/>
<table width="100%" border="1">
<col width="10%">
<tr><td>int</td><td>DdsBuildSequence(DDS_PROCESSOR p)</td></tr>
</table>
See <A href="#DdsCompileGraph">DdsCompileGraph()</a> source code.
<p/>

<hr/>
<a name="REF"/>
<h2>References:</h2>
<ul>
<li>Masao Iri, Junkichi Tsunekawa, Keiji Yajima:The Graphical Techniques Used for a Chemical Process Simulator "JUSE GIFS". IFIP Congress. </li>
<li>Dr. Kazuo Murota (auth.):Systems Analysis by Graphs and Matroids: Structural Solvability and Controllability
(<a href="https://jp1lib.org/book/2264352/362f6b?id=2264352&secret=362f6b" target="_new">download PDF</a>)</li>
<li>K.Yajima, J.Tsunekawa and S.Kobayashi(1981) : On equation - based dynamic simulation. Proceedings. 2nd World Congress of Chemical Engineering, 1981 Montreal, 1981</li>
<li>K.Yajima, J.Tsunekawa, H.Shono, S.Kobayashi and D.J.Sebastian (1982) : On graph - theoretic techniques for large - scale process systems.
 The International symposium on process systems engineering,Kyoto International Conference Hall, Kyoto Japan, August 23-27, 1982</li>
</ul>

<div align="right">
Shigeo Kobayashi 2021-6-10
</div>
<hr/>
<font size="2">
I dedicate this software to two great scientists&amp;mathematicians,my former boss Junkichi Tunekawa and the professor Masao Iri. (They are no longer with us. This software is the proof that I had a time,although it was very short period,to work with them.)
</font>
<hr/>
</body>
</html>
